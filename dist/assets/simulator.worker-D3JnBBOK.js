(function(){"use strict";class S{id;threshold;resetVoltage;voltage;constructor(t){this.id=t.id,this.threshold=t.threshold,this.resetVoltage=t.resetVoltage,this.voltage=t.resetVoltage}reset(){this.voltage=this.resetVoltage}}class x extends S{tau;resistance;constructor(t){super({id:t.id,threshold:t.threshold,resetVoltage:t.resetVoltage??0}),this.tau=t.tau??.02,this.resistance=t.resistance??1}step(t,e){const n=(-this.voltage+this.resistance*t)*(e/this.tau);return this.voltage+=n,this.voltage>=this.threshold?(this.reset(),!0):!1}}class I{pre;post;weight;delay;tau;lastPreSpike;lastPostSpike;constructor(t){this.pre=t.pre,this.post=t.post,this.weight=t.weight,this.delay=t.delay??0,this.tau=t.tau??.01}notifyPreSpike(t){this.lastPreSpike=t}notifyPostSpike(t){this.lastPostSpike=t}computeDeltaT(){return this.lastPreSpike===void 0||this.lastPostSpike===void 0?null:this.lastPostSpike-this.lastPreSpike}computeCurrent(t){if(this.lastPreSpike===void 0)return 0;const e=this.lastPreSpike+this.delay,n=t-e;return n<0?0:this.weight*Math.exp(-n/this.tau)}}class P{neurons;synapses;idToIndex=new Map;constructor(t,e){this.neurons=t,this.synapses=e;for(let n=0;n<t.length;n++)this.idToIndex.set(t[n].id,n)}indexOf(t){const e=this.idToIndex.get(t);if(e===void 0)throw new Error(`Network: unknown neuronId=${t}`);return e}outgoingSynapses(t){return this.synapses.filter(e=>e.pre===t)}incomingSynapses(t){return this.synapses.filter(e=>e.post===t)}}class v{network;dt;time=0;stdp;lastSpikeTimes=new Map;idToIndex;constructor(t,e,n){this.network=t,this.dt=e,this.stdp=n,this.idToIndex=new Map;for(let s=0;s<this.network.neurons.length;s++)this.idToIndex.set(this.network.neurons[s].id,s)}step(t){const e=[],n=this.network.neurons.length,s=new Array(n).fill(0);if(t){const o=Math.min(n,t.length);for(let r=0;r<o;r++){const l=t[r];s[r]+=Number.isFinite(l)?l:0}}for(const o of this.network.synapses){const r=this.idToIndex.get(o.post);r!==void 0&&(s[r]+=o.computeCurrent(this.time))}for(let o=0;o<n;o++){const r=this.network.neurons[o];r.step(s[o],this.dt)&&(e.push({neuronId:r.id,time:this.time}),this.lastSpikeTimes.set(r.id,this.time))}for(const o of e){for(const r of this.network.outgoingSynapses(o.neuronId))r.notifyPreSpike(o.time);for(const r of this.network.incomingSynapses(o.neuronId))r.notifyPostSpike(o.time)}if(this.stdp)for(const o of e){for(const r of this.network.outgoingSynapses(o.neuronId)){const l=this.lastSpikeTimes.get(r.post);l!==void 0&&this.stdp.apply(r,l-o.time)}for(const r of this.network.incomingSynapses(o.neuronId)){const l=this.lastSpikeTimes.get(r.pre);l!==void 0&&this.stdp.apply(r,o.time-l)}}return this.time+=this.dt,e}}class T{tauPlus;tauMinus;aPlus;aMinus;wMin;wMax;constructor(t){this.tauPlus=t.tauPlus,this.tauMinus=t.tauMinus,this.aPlus=t.aPlus,this.aMinus=t.aMinus,this.wMin=t.wMin??-5,this.wMax=t.wMax??5}apply(t,e){if(e>0)t.weight+=this.aPlus*Math.exp(-e/this.tauPlus);else if(e<0)t.weight-=this.aMinus*Math.exp(e/this.tauMinus);else return;t.weight=Math.min(this.wMax,Math.max(this.wMin,t.weight))}}let u=null,c=!1,d=null,f=60,k=null,a=[],p=[];function w(){d!==null&&(clearInterval(d),d=null)}function m(i){self.postMessage({type:"error",message:i instanceof Error?i.message:String(i)})}function h(i,t=0){const e=Number(i);return Number.isFinite(e)?e:t}function N(){if(!u)return[];const i=u.network.neurons.length,t=new Array(i).fill(0);for(let e=0;e<Math.min(i,a.length);e++)t[e]+=a[e]??0;if(p.length){for(const e of p)e.neuronIndex>=0&&e.neuronIndex<i&&e.remainingSteps>0&&(t[e.neuronIndex]+=e.amplitude,e.remainingSteps-=1);p=p.filter(e=>e.remainingSteps>0)}return t}function y(){if(u)try{const i=N(),e=u.step(i).map(s=>({neuronId:s.neuronId,time:s.time})),n=u.network.synapses.map(s=>s.weight);self.postMessage({type:"step",time:u.time,spikes:e,weights:n})}catch(i){m(i)}}function g(){if(!u)return;w(),c=!0;const i=Math.max(1,Math.floor(1e3/f));d=self.setInterval(()=>y(),i)}function M(i){try{c=!1,w(),k=i;const t=(i.neurons??[]).map(o=>new x({id:o.id,threshold:o.threshold})),e=[new I(i.synapse)],n=new P(t,e),s=new T(i.stdp);u=new v(n,i.dt,s),a=new Array(t.length).fill(0),p=[],self.postMessage({type:"meta",neuronCount:t.length})}catch(t){m(t)}}self.onmessage=i=>{const t=i.data??{},e=t.type,n=t.payload;if(e==="init"){M(n);return}if(u){if(e==="step"){y();return}if(e==="setHz"){const s=h(n?.hz,f);s>0&&(f=s,c&&g());return}if(e==="start"){const s=h(n?.hz,f);s>0&&(f=s),g();return}if(e==="pause"){c=!1,w();return}if(e==="resume"){c||g();return}if(e==="restart"){const s=n??k;if(!s)return;M(s),g();return}if(e==="setBias"){const s=Math.floor(h(n?.neuronIndex,-1)),o=h(n?.value,0);s>=0&&s<a.length&&(a[s]=o);return}if(e==="setBiasAll"){const s=h(n?.value,0);a=a.map(()=>s);return}if(e==="pulse"){const s=Math.floor(h(n?.neuronIndex,-1)),o=h(n?.amplitude,0),r=h(n?.durationMs,10),l=Math.max(1,Math.floor(r/1e3/u.dt));s>=0&&s<u.network.neurons.length&&p.push({neuronIndex:s,amplitude:o,remainingSteps:l});return}}}})();
